{
  "lesson_id": "D3-LESSON-006",
  "domain": 3,
  "title": "Cryptography",
  "objectives_covered": [
    "3.4"
  ],
  "estimated_duration": "60-70 minutes",
  "difficulty": "intermediate",
  "version": "2.0-enhanced",
  "skill_tree": {
    "prerequisites": [
      {
        "lesson_id": "D1-LESSON-004",
        "title": "Cryptographic Fundamentals",
        "why_needed": "Provides foundational concepts for this lesson"
      }
    ],
    "unlocks": [
      {
        "lesson_id": "D3-LESSON-008",
        "title": "Data Protection",
        "connection": "Builds upon concepts from this lesson"
      },
      {
        "lesson_id": "D4-LESSON-006",
        "title": "Data Protection",
        "connection": "Builds upon concepts from this lesson"
      }
    ],
    "cascade_learning": {
      "builds_on": [
        {
          "lesson": "D1-LESSON-004",
          "concepts": [
            "Basic encryption concepts",
            "Symmetric vs asymmetric",
            "Hashing fundamentals"
          ]
        }
      ],
      "enables": [
        {
          "lesson": "D3-LESSON-008",
          "concepts": [
            "Data protection through encryption"
          ]
        },
        {
          "lesson": "D4-LESSON-006",
          "concepts": [
            "Operational data protection and key management"
          ]
        }
      ]
    }
  },
  "role_relevance": {
    "soc_analyst": {
      "importance": "medium",
      "daily_tasks": [
        "Understanding encrypted traffic in investigations",
        "Identifying certificate issues causing alerts",
        "Verifying TLS configurations during assessments",
        "Recognizing cryptographic attack indicators"
      ],
      "real_scenario": "Alert shows certificate mismatchâ€”understand PKI to determine if it's misconfiguration or MitM attack"
    },
    "incident_responder": {
      "importance": "medium",
      "daily_tasks": [
        "Dealing with encrypted malware communications",
        "Recovering encrypted data during ransomware",
        "Analyzing cryptographic artifacts in forensics",
        "Understanding encryption in evidence collection"
      ],
      "real_scenario": "Ransomware uses strong encryptionâ€”understand crypto to assess recovery options and determine if decryption is possible"
    },
    "grc_analyst": {
      "importance": "high",
      "daily_tasks": [
        "Auditing encryption implementations for compliance",
        "Ensuring key management meets requirements",
        "Documenting cryptographic controls",
        "Assessing encryption strength against standards"
      ],
      "real_scenario": "PCI DSS requires strong cryptographyâ€”verify AES-256 is used for cardholder data and key rotation procedures exist"
    },
    "penetration_tester": {
      "importance": "high",
      "daily_tasks": [
        "Testing TLS/SSL configurations",
        "Identifying weak cipher suites",
        "Finding certificate vulnerabilities",
        "Exploiting cryptographic implementation flaws"
      ],
      "real_scenario": "SSL scan reveals server supports TLS 1.0 and weak ciphersâ€”demonstrate downgrade attack possibility"
    },
    "security_engineer": {
      "importance": "critical",
      "daily_tasks": [
        "Implementing encryption solutions",
        "Managing PKI infrastructure",
        "Configuring TLS for services",
        "Designing key management systems"
      ],
      "real_scenario": "Implementing certificate automation with Let's Encrypt and internal PKI for service-to-service mTLS"
    }
  },
  "introduction": {
    "hook": "In 2008, researchers demonstrated they could create a rogue CA certificate by exploiting MD5 collision vulnerabilitiesâ€”they could sign any certificate as if it were a trusted authority. The math that seemed secure was broken. Cryptography is the foundation of digital trustâ€”from the lock icon in your browser to the authentication of every API call. Understanding cryptography isn't optional; it's essential for every security decision you make.",
    "learning_goals": [
      "Compare symmetric and asymmetric encryption algorithms and their appropriate uses",
      "Understand hashing algorithms and their role in integrity verification",
      "Implement Public Key Infrastructure (PKI) concepts including certificates and CAs",
      "Apply cryptography to secure communications, storage, and authentication",
      "Recognize cryptographic vulnerabilities and deprecated algorithms"
    ],
    "why_it_matters": {
      "career_impact": "Cryptography protects data confidentiality, verifies integrity, and enables authentication. Weak cryptography = false security. Security professionals evaluate, implement, and troubleshoot cryptographic solutions daily.",
      "business_connection": "",
      "exam_relevance": ""
    },
    "exam_weight": {
      "percentage": "7-9% of Domain 3",
      "question_count": "6-8 questions",
      "question_types": [
        "Algorithm comparison",
        "PKI scenarios",
        "Use case selection"
      ]
    }
  },
  "sections": [
    {
      "section_id": "D3-L006-S01",
      "title": "Symmetric Encryption",
      "content": "Symmetric encryption uses the same key for encryption and decryptionâ€”fast but requires secure key exchange.\n\n**How Symmetric Works**\n\n*Process*\n- Same key encrypts and decrypts\n- Key must be shared securely\n- Fast, efficient for bulk data\n- Key management is challenge\n\n*Key Exchange Problem*\n- How do you share the key securely?\n- If key compromised, all data exposed\n- Each pair needs unique key\n- Doesn't scale well (n*(n-1)/2 keys)\n\n**Block Ciphers**\n\n*AES (Advanced Encryption Standard)*\n- Current standard (replaced DES)\n- Key sizes: 128, 192, 256 bits\n- Block size: 128 bits\n- Approved for government use\n- AES-256 for sensitive data\n\n*Modes of Operation*\n- ECB (Electronic Codebook): Same plaintext = same ciphertext (weak)\n- CBC (Cipher Block Chaining): Uses IV, blocks linked\n- CTR (Counter): Turns block cipher into stream\n- GCM (Galois/Counter Mode): Encryption + authentication\n\n*DES/3DES (Legacy)*\n- DES: 56-bit keyâ€”broken, never use\n- 3DES: Three DES operationsâ€”deprecated\n- Both should be replaced with AES\n\n**Stream Ciphers**\n\n*Characteristics*\n- Encrypt bit by bit or byte by byte\n- Fast, low latency\n- Used for real-time data\n- Keystream must never repeat\n\n*Examples*\n- RC4: Broken, never use\n- ChaCha20: Modern, secure\n- Used in TLS, mobile devices\n\n**Symmetric Algorithm Selection**\n\n*Use AES-256 for*\n- Data at rest encryption\n- Database encryption\n- File/disk encryption\n- VPN tunnels (bulk data)\n\n*Use ChaCha20 for*\n- Mobile devices (no AES hardware)\n- TLS alternative to AES\n- Real-time communications",
      "key_points": [
        "Symmetric: same key encrypts and decryptsâ€”fast but key distribution problem",
        "AES is the standard: 128, 192, or 256-bit keys; use AES-256 for sensitive data",
        "ECB mode is weak (patterns visible); use CBC, CTR, or GCM instead",
        "DES (56-bit) and RC4 are brokenâ€”never use",
        "GCM mode provides both encryption and authentication (integrity)"
      ],
      "memory_hooks": {
        "mnemonics": [
          {
            "name": "AES = Always Encrypt Securely",
            "expansion": "AES is the secure choice for symmetric encryption",
            "usage": "Remember AES is the standard"
          },
          {
            "name": "ECB = Each Block Copies (patterns)",
            "expansion": "ECB shows patternsâ€”same plaintext = same ciphertext",
            "usage": "Remember why ECB is weak"
          }
        ],
        "analogies": [
          {
            "concept": "Symmetric Encryption",
            "analogy": "Like a safe where both you and your friend have the same keyâ€”you can both lock and unlock it, but you had to meet to copy the key",
            "why_it_works": "Same key for both operations, but key exchange is the challenge"
          },
          {
            "concept": "ECB vs CBC",
            "analogy": "ECB is like using the same padlock on every lockerâ€”patterns emerge. CBC is like each locker's lock depending on the previous oneâ€”no patterns.",
            "why_it_works": "ECB's weakness is visible patterns in repeated data"
          }
        ],
        "common_mistakes": [
          {
            "mistake": "Thinking longer key always means more secure",
            "correction": "Algorithm matters more than key length. AES-128 is secure. RC4 with any key length is broken. Algorithm strength + key length = security.",
            "exam_trap": "AES-128 is acceptable; broken algorithm with longer key is not",
            "why_wrong": "This common misconception leads to gaps in security implementation and incorrect exam answers.",
            "correct": "Review the actual behavior and characteristics of this concept."
          },
          {
            "mistake": "Using ECB mode for any encryption",
            "correction": "ECB reveals patterns in data. Never use ECB. Use CBC (with random IV), CTR, or GCM for confidentiality.",
            "exam_trap": "If ECB is mentioned, it's usually the wrong answer",
            "why_wrong": "Incorrect usage can reduce effectiveness or create vulnerabilities.",
            "correct": "Review the official definition and understand both the concept and its practical application."
          }
        ]
      },
      "what_would_happen_if": [
        {
          "situation": "Images encrypted with AES in ECB mode",
          "consequence": "Penguin problemâ€”encrypted image shows outline of original because same pixel patterns create same ciphertext. Pattern analysis possible. Confidentiality compromised.",
          "lesson": "Never use ECB. Patterns in plaintext become patterns in ciphertext."
        },
        {
          "situation": "Organization continues using 3DES after deprecation",
          "consequence": "Compliance failures (PCI DSS, NIST guidance). Slower than AES. Known weaknesses. Eventually will fail audits. Technical debt accumulates.",
          "lesson": "Deprecated algorithms must be replaced. AES is faster AND more secure."
        }
      ],
      "knowledge_check": {
        "question": "A security architect needs to select an encryption algorithm for encrypting sensitive files stored on a database server. Which choice is most appropriate?",
        "options": [
          "3DES for backward compatibility",
          "AES-256 in GCM mode",
          "RC4 for speed",
          "AES-128 in ECB mode"
        ],
        "correct": 1,
        "explanation": "AES-256 in GCM mode provides strong encryption (256-bit key) with authenticated encryption (integrity verification). GCM prevents tampering detection. 3DES is deprecated, RC4 is broken, ECB mode reveals patterns.",
        "wrong_answer_analysis": {
          "0": "3DES is deprecatedâ€”should be replaced with AES.",
          "2": "RC4 is brokenâ€”never use for any purpose.",
          "3": "ECB mode reveals patternsâ€”never use for data encryption."
        }
      },
      "must_remember_for_exam": [
        {
          "point": "AES key sizes: 128, 192, 256 bits; AES-256 for sensitive data",
          "why_tested": "Know AES key sizes and when to use which."
        },
        {
          "point": "ECB mode is weakâ€”reveals patterns; use CBC, CTR, or GCM",
          "why_tested": "Common question about modes of operation."
        },
        {
          "point": "DES, 3DES, RC4 are deprecated/brokenâ€”use AES",
          "why_tested": "Know which algorithms to avoid."
        }
      ],
      "glossary_terms": [
        {
          "term": "Symmetric Encryption",
          "definition": "Encryption method using the same key for both encryption and decryption, efficient for bulk data but requiring secure key exchange.",
          "exam_note": "Same key both ways. Fast. Key exchange problem."
        },
        {
          "term": "AES (Advanced Encryption Standard)",
          "definition": "The current standard symmetric encryption algorithm supporting 128, 192, and 256-bit keys with 128-bit block size.",
          "exam_note": "Current standard. 128/192/256-bit keys. Replaced DES."
        },
        {
          "term": "GCM (Galois/Counter Mode)",
          "definition": "An authenticated encryption mode that provides both confidentiality and integrity verification in a single operation.",
          "exam_note": "Encryption + authentication. Detects tampering. Preferred mode."
        },
        {
          "term": "ECB (Electronic Codebook)",
          "definition": "A block cipher mode that encrypts each block independently, revealing patterns in data and considered insecure for most uses.",
          "exam_note": "Weak. Patterns visible. Never use. Same plaintext = same ciphertext."
        }
      ],
      "exam_tips": [
        "AES is symmetric (same key encrypts/decrypts), RSA is asymmetric (public/private keys)",
        "Hashing is ONE-WAY - you cannot decrypt a hash"
      ],
      "deep_dive": [
        {
          "title": "Block Cipher Modes",
          "content": "ECB (Electronic Codebook): Same plaintext = same ciphertext, don't use. CBC (Cipher Block Chaining): Each block XORed with previous, needs IV, padding required. CTR (Counter): Converts block cipher to stream cipher, parallelizable. GCM (Galois/Counter Mode): CTR + authentication, recommended mode. Best practice: Use GCM for authenticated encryption, never use ECB."
        }
      ],
      "career_spotlight": {
        "role": "Cryptographic Engineer",
        "daily_tasks": [
          "Implementing cryptographic solutions",
          "Reviewing cryptographic designs",
          "Selecting appropriate algorithms",
          "Managing encryption systems",
          "Advising on cryptographic standards"
        ],
        "tools_used": [
          "OpenSSL",
          "BouncyCastle",
          "HSMs",
          "Crypto libraries"
        ],
        "career_path": "Developer → Security Engineer → Crypto Engineer → Cryptographic Architect"
      }
    },
    {
      "section_id": "D3-L006-S02",
      "title": "Asymmetric Encryption",
      "content": "Asymmetric encryption uses key pairsâ€”public and privateâ€”solving the key distribution problem.\n\n**How Asymmetric Works**\n\n*Key Pairs*\n- Public key: Shared openly\n- Private key: Kept secret\n- Mathematically related\n- Cannot derive private from public\n\n*Two Uses*\n- Encryption: Encrypt with public, decrypt with private\n- Signing: Sign with private, verify with public\n\n*Solving Key Exchange*\n- No pre-shared secret needed\n- Public keys can be distributed openly\n- Only private key owner can decrypt\n- Enables secure communication with strangers\n\n**RSA**\n\n*Characteristics*\n- Most widely used\n- Based on factoring large primes\n- Key sizes: 2048, 3072, 4096 bits\n- Minimum 2048 bits (4096 for sensitive)\n- Slower than symmetric\n\n*Uses*\n- Key exchange\n- Digital signatures\n- Certificate signing\n- Not for bulk data (too slow)\n\n**Elliptic Curve Cryptography (ECC)**\n\n*Advantages*\n- Smaller keys, same security\n- 256-bit ECC â‰ˆ 3072-bit RSA\n- Faster operations\n- Less computational overhead\n- Better for mobile/IoT\n\n*Common Curves*\n- P-256, P-384, P-521 (NIST)\n- Curve25519 (modern, trusted)\n\n**Diffie-Hellman**\n\n*Purpose*\n- Key exchange protocol\n- Establishes shared secret\n- Over insecure channel\n- Used in TLS handshake\n\n*Variations*\n- DH: Original algorithm\n- DHE: Ephemeral (forward secrecy)\n- ECDHE: Elliptic Curve DHE\n\n**Hybrid Encryption**\n\n*Why Hybrid*\n- Asymmetric too slow for bulk data\n- Symmetric fast but key exchange problem\n- Solution: Use both\n\n*Process*\n1. Generate random symmetric key\n2. Encrypt data with symmetric key (fast)\n3. Encrypt symmetric key with recipient's public key\n4. Send both encrypted key and encrypted data",
      "key_points": [
        "Asymmetric uses key pairs: public (share) and private (keep secret)",
        "Encrypt with public key, decrypt with private key; sign with private, verify with public",
        "RSA minimum 2048 bits; ECC provides same security with smaller keys",
        "Diffie-Hellman enables key exchange; ECDHE provides forward secrecy",
        "Hybrid encryption: asymmetric for key exchange, symmetric for data"
      ],
      "memory_hooks": {
        "mnemonics": [
          {
            "name": "Public = Encrypt, Private = Decrypt (for confidentiality)",
            "expansion": "Encrypt with recipient's public key; only they can decrypt with private",
            "usage": "Remember encryption direction"
          },
          {
            "name": "Private = Sign, Public = Verify (for authenticity)",
            "expansion": "Sign with your private key; anyone can verify with your public",
            "usage": "Remember signing direction"
          }
        ],
        "analogies": [
          {
            "concept": "Public/Private Keys",
            "analogy": "Public key is like a mailbox slot (anyone can drop in messages). Private key is the mailbox key (only owner can retrieve messages).",
            "why_it_works": "Anyone can encrypt to you; only you can decrypt"
          },
          {
            "concept": "Digital Signature",
            "analogy": "Like a wax seal that only you have the stamp forâ€”anyone can see and verify it's your seal, but only you can create it",
            "why_it_works": "Sign with private (unique to you), verify with public (available to all)"
          }
        ],
        "common_mistakes": [
          {
            "mistake": "Using asymmetric encryption for bulk data",
            "correction": "Asymmetric is too slow for large data. Use hybrid: asymmetric to exchange symmetric key, then symmetric for data.",
            "exam_trap": "Asymmetric for key exchange; symmetric for data encryption",
            "why_wrong": "Incorrect usage can reduce effectiveness or create vulnerabilities.",
            "correct": "Review the official definition and understand both the concept and its practical application."
          },
          {
            "mistake": "Thinking 256-bit ECC equals 256-bit RSA",
            "correction": "Key lengths don't compare directly across algorithms. 256-bit ECC â‰ˆ 3072-bit RSA in security strength.",
            "exam_trap": "Know ECC provides equivalent security with shorter keys",
            "why_wrong": "This common misconception leads to gaps in security implementation and incorrect exam answers.",
            "correct": "Review the actual behavior and characteristics of this concept."
          }
        ]
      },
      "what_would_happen_if": [
        {
          "situation": "RSA key size of 1024 bits used for certificate",
          "consequence": "Key considered weak. Can be factored with sufficient resources. Certificate won't be trusted by modern browsers. Compliance failures.",
          "lesson": "RSA minimum 2048 bits. 4096 for highly sensitive. 1024 is deprecated."
        },
        {
          "situation": "TLS configured without forward secrecy (DHE/ECDHE)",
          "consequence": "If server private key compromised later, all past recorded traffic can be decrypted. No protection for historical communications.",
          "lesson": "Use DHE or ECDHE for forward secrecyâ€”each session has unique keys."
        }
      ],
      "knowledge_check": {
        "question": "A security engineer needs to establish a secure communication channel that provides forward secrecy. Which key exchange mechanism should be used?",
        "options": [
          "RSA key exchange",
          "Static Diffie-Hellman",
          "Ephemeral Diffie-Hellman (DHE/ECDHE)",
          "Pre-shared key (PSK)"
        ],
        "correct": 2,
        "explanation": "Ephemeral Diffie-Hellman (DHE or ECDHE) generates new key pairs for each session, providing forward secrecy. If long-term keys are compromised, past sessions remain protected. RSA key exchange and static DH don't provide forward secrecy.",
        "wrong_answer_analysis": {
          "0": "RSA key exchange doesn't provide forward secrecyâ€”compromised private key exposes all past sessions.",
          "1": "Static DH uses same keys repeatedlyâ€”no forward secrecy.",
          "3": "PSK doesn't provide forward secrecyâ€”compromised PSK exposes all sessions."
        }
      },
      "must_remember_for_exam": [
        {
          "point": "RSA minimum 2048 bits; ECC 256-bit â‰ˆ RSA 3072-bit",
          "why_tested": "Know minimum key sizes and ECC equivalence."
        },
        {
          "point": "ECDHE provides forward secrecy; static RSA does not",
          "why_tested": "Forward secrecy is important TLS concept."
        },
        {
          "point": "Hybrid encryption = asymmetric for key exchange + symmetric for data",
          "why_tested": "Understand why both are used together."
        }
      ],
      "glossary_terms": [
        {
          "term": "Asymmetric Encryption",
          "definition": "Encryption using mathematically related key pairs where the public key encrypts and the private key decrypts, or private signs and public verifies.",
          "exam_note": "Key pairs. Public/private. Solves key exchange. Slower than symmetric."
        },
        {
          "term": "RSA",
          "definition": "An asymmetric algorithm based on the difficulty of factoring large prime numbers, used for encryption and digital signatures with key sizes of 2048+ bits.",
          "exam_note": "Most common asymmetric. 2048-bit minimum. Key exchange and signing."
        },
        {
          "term": "Elliptic Curve Cryptography (ECC)",
          "definition": "Asymmetric cryptography using elliptic curve mathematics, providing equivalent security to RSA with much smaller key sizes.",
          "exam_note": "Smaller keys. 256-bit â‰ˆ 3072-bit RSA. Mobile/IoT friendly."
        },
        {
          "term": "Forward Secrecy",
          "definition": "A property ensuring that compromise of long-term keys doesn't compromise past session keys, protecting historical encrypted communications.",
          "exam_note": "DHE/ECDHE provides it. Past traffic protected. Ephemeral keys."
        }
      ],
      "exam_tips": [
        "AES is symmetric (same key encrypts/decrypts), RSA is asymmetric (public/private keys)",
        "Hashing is ONE-WAY - you cannot decrypt a hash"
      ],
      "deep_dive": [
        {
          "title": "Elliptic Curve Cryptography",
          "content": "ECC benefits: Smaller keys for equivalent security (256-bit ECC ≈ 3072-bit RSA), faster operations, less bandwidth. Common curves: P-256 (NIST), P-384, Curve25519. Use cases: TLS handshakes, mobile/IoT, digital signatures. Considerations: Curve selection matters, some curves have concerns, post-quantum not resistant. Recommendation: Use for performance-sensitive applications."
        }
      ],
      "career_spotlight": {
        "role": "PKI Engineer",
        "daily_tasks": [
          "Managing certificate authorities",
          "Issuing certificates",
          "Implementing certificate lifecycle",
          "Troubleshooting PKI issues",
          "Planning PKI architecture"
        ],
        "tools_used": [
          "Microsoft CA",
          "EJBCA",
          "Venafi",
          "OpenSSL"
        ],
        "career_path": "Systems Admin → PKI Admin → PKI Engineer → Security Architect"
      },
      "real_world_example": {
        "title": "Heartbleed OpenSSL Vulnerability",
        "incident": "Buffer over-read in OpenSSL (2014) leaked server memory including private keys. Affected 17% of secure websites. Required mass certificate reissuance.",
        "impact": "Billions spent on remediation. Highlighted open-source security funding needs. Led to Core Infrastructure Initiative.",
        "lesson": "Critical crypto libraries need security investment. Have certificate reissuance procedures ready."
      }
    },
    {
      "section_id": "D3-L006-S03",
      "title": "Hashing and Digital Signatures",
      "content": "Hashing provides integrity verification; digital signatures provide integrity plus authenticity.\n\n**Hash Functions**\n\n*Properties*\n- Fixed-size output regardless of input\n- One-way (cannot reverse)\n- Deterministic (same input = same output)\n- Collision resistant (hard to find two inputs with same hash)\n\n*Uses*\n- Password storage\n- File integrity verification\n- Digital signatures\n- Blockchain/cryptocurrency\n- Message authentication codes\n\n**Hash Algorithms**\n\n*MD5*\n- 128-bit output\n- Collision attacks proven\n- Never use for security\n- Legacy systems only\n\n*SHA-1*\n- 160-bit output\n- Collision attacks demonstrated\n- Deprecated for most uses\n- Being phased out\n\n*SHA-2 Family*\n- SHA-256: 256-bit output (common)\n- SHA-384: 384-bit output\n- SHA-512: 512-bit output\n- Current standard for security\n\n*SHA-3*\n- Different design (Keccak)\n- Alternative to SHA-2\n- Not a replacement (SHA-2 still secure)\n- Backup if SHA-2 weakened\n\n**Digital Signatures**\n\n*Process*\n1. Hash the message\n2. Encrypt hash with private key\n3. Attach signature to message\n4. Recipient decrypts with public key\n5. Compare hashes for verification\n\n*Provides*\n- Integrity (message not modified)\n- Authentication (from claimed sender)\n- Non-repudiation (sender cannot deny)\n\n**HMAC**\n\n*Hash-based Message Authentication Code*\n- Combines hash with secret key\n- Verifies integrity AND authenticity\n- Faster than digital signatures\n- Symmetric (shared secret)\n\n**Password Hashing**\n\n*Special Requirements*\n- Must be slow (resist brute force)\n- Use salts (prevent rainbow tables)\n- Memory-hard (resist GPU attacks)\n\n*Algorithms*\n- bcrypt: Time-tested, adjustable cost\n- scrypt: Memory-hard\n- Argon2: Modern winner, recommended",
      "key_points": [
        "Hashing is one-wayâ€”cannot reverse to get original data",
        "MD5 and SHA-1 are broken for securityâ€”use SHA-256 or higher",
        "Digital signatures provide integrity, authentication, and non-repudiation",
        "Sign with private key, verify with public key",
        "Password hashing needs slowness and saltsâ€”use bcrypt, scrypt, or Argon2"
      ],
      "memory_hooks": {
        "mnemonics": [
          {
            "name": "MD5-SHA1 = Must Discard, Should Have Already",
            "expansion": "MD5 and SHA-1 are deprecatedâ€”don't use for security",
            "usage": "Remember deprecated hash algorithms"
          },
          {
            "name": "IAN for Digital Signatures",
            "expansion": "Integrity, Authentication, Non-repudiation",
            "usage": "Three things digital signatures provide"
          }
        ],
        "analogies": [
          {
            "concept": "Hash Function",
            "analogy": "Like a fingerprintâ€”unique identifier for data, but you can't recreate the person from the fingerprint",
            "why_it_works": "One-way function that uniquely identifies data"
          },
          {
            "concept": "Salt in Password Hashing",
            "analogy": "Like adding unique ingredients to each recipeâ€”even if two people use the same password, their stored hashes are different because of unique salts",
            "why_it_works": "Salts prevent rainbow table attacks"
          }
        ],
        "common_mistakes": [
          {
            "mistake": "Using MD5 for password hashing",
            "correction": "MD5 is fast (bad for passwords) and has collisions. Use bcrypt, scrypt, or Argon2 which are intentionally slow and salt by design.",
            "exam_trap": "Password hashing algorithms are different from general-purpose hashes",
            "why_wrong": "Incorrect usage can reduce effectiveness or create vulnerabilities.",
            "correct": "Review the official definition and understand both the concept and its practical application."
          },
          {
            "mistake": "Thinking hashing provides confidentiality",
            "correction": "Hashing provides integrity onlyâ€”you can verify data hasn't changed, but the data itself isn't secret. Encryption provides confidentiality.",
            "exam_trap": "Hash = integrity; Encryption = confidentiality",
            "why_wrong": "This common misconception leads to gaps in security implementation and incorrect exam answers.",
            "correct": "Review the actual behavior and characteristics of this concept."
          }
        ]
      },
      "what_would_happen_if": [
        {
          "situation": "Website stores passwords with SHA-256 (no salt, fast hash)",
          "consequence": "Rainbow tables can reverse common passwords. GPU can brute-force quickly. One breach exposes all users with same password.",
          "lesson": "Password hashing must be slow and salted. Use bcrypt/scrypt/Argon2, not SHA-256."
        },
        {
          "situation": "Software verification uses MD5 hashes",
          "consequence": "Attacker can create malicious file with same MD5 hash. User downloads malware thinking it's verified. Integrity check bypassed.",
          "lesson": "MD5 collisions are practical. Use SHA-256 for file integrity."
        }
      ],
      "knowledge_check": {
        "question": "A developer needs to securely store user passwords. Which approach is most appropriate?",
        "options": [
          "AES-256 encryption of passwords",
          "SHA-256 hashing without salt",
          "bcrypt with unique salt per password",
          "MD5 with application-wide salt"
        ],
        "correct": 2,
        "explanation": "bcrypt is designed for password hashingâ€”it's intentionally slow, uses salts automatically, and has adjustable difficulty. Encryption is reversible (not wanted for passwords). SHA-256 is too fast. MD5 is broken.",
        "wrong_answer_analysis": {
          "0": "Encryption is reversibleâ€”if key compromised, all passwords exposed. Hashing is one-way.",
          "1": "SHA-256 is too fast for password hashing and no salt enables rainbow tables.",
          "3": "MD5 is broken and application-wide salt doesn't prevent same-password detection."
        }
      },
      "must_remember_for_exam": [
        {
          "point": "MD5 (128-bit) and SHA-1 (160-bit) are brokenâ€”use SHA-256+",
          "why_tested": "Know which hashes are deprecated."
        },
        {
          "point": "Digital signatures provide: integrity, authentication, non-repudiation",
          "why_tested": "Know what signatures provide (vs encryption)."
        },
        {
          "point": "Password hashing: bcrypt, scrypt, Argon2 (slow + salt)",
          "why_tested": "Password-specific algorithms are different from general hashes."
        }
      ],
      "glossary_terms": [
        {
          "term": "Hash Function",
          "definition": "A one-way function that converts input of any size into a fixed-size output, used for integrity verification and password storage.",
          "exam_note": "One-way. Fixed output. Collision resistance. Integrity verification."
        },
        {
          "term": "Digital Signature",
          "definition": "A cryptographic mechanism using private key to sign data, providing integrity, authentication, and non-repudiation when verified with public key.",
          "exam_note": "Sign with private. Verify with public. IAN: Integrity, Auth, Non-repudiation."
        },
        {
          "term": "Non-repudiation",
          "definition": "The assurance that someone cannot deny the authenticity of their signature or sending a message, typically provided by digital signatures.",
          "exam_note": "Cannot deny action. Digital signatures provide. Requires private key use."
        },
        {
          "term": "Salt",
          "definition": "Random data added to passwords before hashing to ensure identical passwords produce different hashes, preventing rainbow table attacks.",
          "exam_note": "Unique per password. Prevents rainbow tables. Stored with hash."
        }
      ],
      "exam_tips": [
        "Memorize the three authentication factors: Something you know, have, are",
        "Understand MFA requires factors from DIFFERENT categories"
      ],
      "deep_dive": [
        {
          "title": "Hash Algorithm Selection",
          "content": "Deprecated: MD5 (collisions found), SHA-1 (collisions demonstrated). Current: SHA-256/SHA-384/SHA-512 (SHA-2 family), SHA-3 (Keccak). Password hashing: bcrypt, Argon2, scrypt - not SHA! File integrity: SHA-256 minimum. Digital signatures: SHA-256 or SHA-384. Future: SHA-3 for new applications, post-quantum considerations."
        }
      ],
      "career_spotlight": {
        "role": "Security Developer",
        "daily_tasks": [
          "Implementing secure coding practices",
          "Using cryptographic APIs correctly",
          "Reviewing code for security",
          "Fixing security vulnerabilities",
          "Writing secure libraries"
        ],
        "tools_used": [
          "SAST tools",
          "Crypto libraries",
          "IDE security plugins",
          "Code review tools"
        ],
        "career_path": "Developer → Security-focused Developer → Security Developer → Security Architect"
      },
      "real_world_example": {
        "title": "LinkedIn Password Breach",
        "incident": "LinkedIn stored passwords with unsalted SHA-1. When breached (2012), 117 million password hashes cracked quickly. Same passwords reused elsewhere.",
        "impact": "Mass password reuse exploitation. Credential stuffing attacks. Demonstrated proper password hashing importance.",
        "lesson": "Never SHA for passwords. Use bcrypt/Argon2. Salting is not optional."
      }
    },
    {
      "section_id": "D3-L006-S04",
      "title": "Public Key Infrastructure (PKI)",
      "content": "PKI provides the framework for managing digital certificates and public key encryption at scale.\n\n**PKI Components**\n\n*Certificate Authority (CA)*\n- Issues digital certificates\n- Verifies identity before issuance\n- Signs certificates with CA private key\n- Root CA â†’ Intermediate CA â†’ End entity\n\n*Registration Authority (RA)*\n- Verifies certificate requests\n- Front-end for CA\n- Doesn't issue certificates\n- Identity verification role\n\n*Certificate Repository*\n- Stores issued certificates\n- Makes certificates available\n- LDAP or web-based\n\n**Digital Certificates**\n\n*X.509 Standard*\n- Subject (who certificate identifies)\n- Issuer (CA that signed it)\n- Public key\n- Validity period\n- Serial number\n- Signature algorithm\n- Digital signature\n\n*Certificate Types*\n- DV (Domain Validation): Domain ownership only\n- OV (Organization Validation): Organization verified\n- EV (Extended Validation): Extensive verification\n- Wildcard: *.domain.com\n- SAN: Multiple domains in one cert\n\n**Certificate Lifecycle**\n\n*Issuance*\n1. Generate key pair\n2. Create Certificate Signing Request (CSR)\n3. Submit to CA/RA\n4. CA verifies identity\n5. CA signs and issues certificate\n\n*Revocation*\n- CRL (Certificate Revocation List): Periodic list\n- OCSP (Online Certificate Status Protocol): Real-time check\n- Revoke when: key compromised, info changed, CA compromised\n\n*Expiration*\n- Certificates have validity period\n- Must renew before expiration\n- Automate renewal (Let's Encrypt)\n\n**Trust Models**\n\n*Hierarchical (CA)*\n- Single root of trust\n- Chain of trust downward\n- Most common (web PKI)\n\n*Web of Trust*\n- Peer verification\n- No central authority\n- Used in PGP\n\n**Certificate Pinning**\n\n*Purpose*\n- Prevents MitM with rogue certs\n- Application trusts specific cert only\n- Bypasses normal CA validation\n- Common in mobile apps",
      "key_points": [
        "CA issues and signs certificates; RA verifies identity",
        "X.509 certificates contain subject, issuer, public key, validity, signature",
        "DV = domain only; OV = organization verified; EV = extensive verification",
        "CRL is periodic list; OCSP is real-time revocation check",
        "Certificate chain: Root CA â†’ Intermediate CA â†’ End entity certificate"
      ],
      "memory_hooks": {
        "mnemonics": [
          {
            "name": "CRA",
            "expansion": "CA (issues), RA (verifies), Authority structure",
            "usage": "PKI authority roles"
          },
          {
            "name": "DOVE",
            "expansion": "DV (Domain), OV (Organization), EV (Extended) Validation",
            "usage": "Certificate validation levels from low to high"
          }
        ],
        "analogies": [
          {
            "concept": "Certificate Authority",
            "analogy": "Like a passport officeâ€”verifies your identity and issues an official document that others trust because they trust the issuing authority",
            "why_it_works": "CA verifies identity and issues trusted credential"
          },
          {
            "concept": "Certificate Chain",
            "analogy": "Like a chain of vouchesâ€”Root CA vouches for Intermediate CA, which vouches for the website. You trust the root, so you trust the chain.",
            "why_it_works": "Trust flows from root through intermediates to end entity"
          }
        ],
        "common_mistakes": [
          {
            "mistake": "Thinking EV certificates provide more encryption",
            "correction": "DV, OV, and EV all use the same encryption. The difference is identity verification levelâ€”how much the CA verified before issuing.",
            "exam_trap": "Validation level is about identity verification, not encryption strength",
            "why_wrong": "This common misconception leads to gaps in security implementation and incorrect exam answers.",
            "correct": "Review the actual behavior and characteristics of this concept."
          },
          {
            "mistake": "Ignoring certificate expiration until it fails",
            "correction": "Expired certificates cause outages and security warnings. Automate certificate renewal. Monitor expiration dates. Use tools like Let's Encrypt.",
            "exam_trap": "Certificate management includes monitoring expiration",
            "why_wrong": "Ignoring this element compromises the overall security posture.",
            "correct": "Include all relevant components in your security strategy."
          }
        ]
      },
      "what_would_happen_if": [
        {
          "situation": "Root CA private key is compromised",
          "consequence": "All certificates issued by that CA chain are untrustworthy. Attacker can issue certificates for any domain. Browsers must remove CA from trust store. Massive remediation required.",
          "lesson": "Root CA keys are extremely sensitive. Keep offline. Use intermediates for day-to-day signing."
        },
        {
          "situation": "Website continues using certificate after private key compromise",
          "consequence": "Attacker can decrypt traffic. MitM attacks possible. Certificate should be revoked immediately. Users at risk until new certificate deployed.",
          "lesson": "Compromised key = immediate revocation. Don't wait for expiration."
        }
      ],
      "knowledge_check": {
        "question": "A user receives a certificate error when connecting to their bank's website. Investigation shows the certificate was signed by a CA not in the browser's trust store. What is the most likely issue?",
        "options": [
          "The certificate has expired",
          "The certificate uses weak encryption",
          "The certificate chain is incomplete or untrusted",
          "The certificate is using an unsupported protocol"
        ],
        "correct": 2,
        "explanation": "If the CA isn't trusted, the certificate chain cannot be validated. This could be a missing intermediate certificate, self-signed certificate, or potentially a MitM attack with a rogue certificate. The chain must lead to a trusted root.",
        "wrong_answer_analysis": {
          "0": "Expiration would give a different error message specifically about dates.",
          "1": "Weak encryption would be a cipher/protocol issue, not a trust issue.",
          "3": "Protocol issues would be reported differently from trust issues."
        }
      },
      "must_remember_for_exam": [
        {
          "point": "CA issues certificates; RA verifies identity",
          "why_tested": "Know PKI component roles."
        },
        {
          "point": "CRL = periodic revocation list; OCSP = real-time check",
          "why_tested": "Revocation methods commonly tested."
        },
        {
          "point": "Root CA â†’ Intermediate CA â†’ End entity (certificate chain)",
          "why_tested": "Understand chain of trust."
        }
      ],
      "glossary_terms": [
        {
          "term": "Certificate Authority (CA)",
          "definition": "A trusted entity that issues digital certificates after verifying the identity of the requester, signing certificates with its private key.",
          "exam_note": "Issues certificates. Verifies identity. Signs with private key. Root of trust."
        },
        {
          "term": "Certificate Revocation List (CRL)",
          "definition": "A periodically published list of revoked certificates maintained by the CA, allowing validation of certificate status.",
          "exam_note": "Periodic list. Published by CA. Not real-time."
        },
        {
          "term": "OCSP (Online Certificate Status Protocol)",
          "definition": "A protocol for real-time verification of certificate revocation status as an alternative to CRL checking.",
          "exam_note": "Real-time check. Alternative to CRL. Faster validation."
        },
        {
          "term": "Certificate Signing Request (CSR)",
          "definition": "A message sent to a CA containing the public key and identification information, requesting a signed digital certificate.",
          "exam_note": "Request for certificate. Contains public key. Sent to CA."
        }
      ],
      "exam_tips": [
        "AES is symmetric (same key encrypts/decrypts), RSA is asymmetric (public/private keys)",
        "Hashing is ONE-WAY - you cannot decrypt a hash"
      ],
      "deep_dive": [
        {
          "title": "Certificate Lifecycle Management",
          "content": "Lifecycle: Request → Approval → Issuance → Installation → Monitoring → Renewal → Revocation. Automation: ACME protocol (Let's Encrypt), certificate management platforms. Monitoring: Track expiration, certificate transparency. Revocation: CRL and OCSP. Common issues: Expired certificates cause outages, manual tracking doesn't scale, wildcard certificate risks."
        }
      ],
      "career_spotlight": {
        "role": "Certificate Manager",
        "daily_tasks": [
          "Tracking certificate inventory",
          "Managing certificate renewals",
          "Implementing automation",
          "Responding to certificate issues",
          "Auditing certificate compliance"
        ],
        "tools_used": [
          "Venafi",
          "DigiCert CertCentral",
          "Let's Encrypt",
          "Certificate monitoring"
        ],
        "career_path": "IT Admin → Certificate Admin → Certificate Manager → PKI Architect"
      },
      "real_world_example": {
        "title": "Equifax Certificate Expiration",
        "incident": "Equifax had expired certificate on security monitoring tool for 19 months. This contributed to delayed detection of the massive 2017 breach.",
        "impact": "147 million records exposed. Expired certificate meant encrypted malicious traffic wasn't inspected.",
        "lesson": "Certificate management is security critical. Automate certificate monitoring. Expired certs cause blind spots."
      }
    }
  ],
  "hands_on_activity": {
    "title": "Cryptographic Assessment",
    "objective": "Evaluate cryptographic implementations for security weaknesses",
    "scenario": "You're assessing cryptographic controls at Meridian Financial. Review encryption, hashing, and PKI implementations.",
    "steps": [
      "Step 1: Inventory encryption algorithms in useâ€”identify any deprecated (DES, 3DES, RC4)",
      "Step 2: Review TLS configurationsâ€”check for weak cipher suites and protocol versions",
      "Step 3: Assess password storageâ€”verify bcrypt/scrypt/Argon2 with salts",
      "Step 4: Review certificate managementâ€”expiration dates, key sizes, chain validity",
      "Step 5: Check key management practicesâ€”storage, rotation, access controls",
      "Step 6: Document findings and prioritize remediation"
    ],
    "expected_outcome": "Cryptographic assessment report identifying weak algorithms, misconfigurations, and remediation priorities.",
    "exercises": [
      {
        "use_case": "Encrypting database containing customer PII",
        "algorithm": "AES-256-GCM",
        "key_management": "HSM-backed key with rotation policy",
        "considerations": "Performance impact, search capability, backup encryption"
      },
      {
        "use_case": "Signing software releases",
        "algorithm": "RSA-4096 or ECDSA P-384",
        "key_management": "Offline root CA, code signing certificate",
        "considerations": "Key protection, revocation process, timestamp"
      },
      {
        "use_case": "Hashing passwords for storage",
        "algorithm": "Argon2id or bcrypt",
        "key_management": "Salt per password, work factor tuning",
        "considerations": "Not encryption - one-way only, GPU resistance"
      },
      {
        "use_case": "TLS for web server",
        "algorithm": "TLS 1.3 with ECDHE + AES-GCM",
        "key_management": "Certificate from trusted CA, key pinning optional",
        "considerations": "Cipher suite selection, certificate lifecycle"
      }
    ],
    "reflection_questions": [
      "When would you choose symmetric vs asymmetric encryption?",
      "Why are password hashes different from cryptographic hashes like SHA-256?",
      "What makes some algorithms 'quantum-resistant'?"
    ]
  },
  "what_would_you_do": {
    "scenario": "Legacy application uses MD5 to hash passwords. Development team says migration to bcrypt would require significant refactoring and testing.",
    "context": "Application has 50,000 users. No breaches yet. Budget is constrained. Refactoring estimate is 3 weeks of development.",
    "question": "How do you prioritize this remediation?",
    "options": [
      {
        "id": "a",
        "text": "Accept the riskâ€”no breaches have occurred yet",
        "is_best": false,
        "feedback": "Past success doesn't predict future security. MD5 is broken. When breach occurs, all passwords instantly compromised. Regulatory/legal liability.",
        "consequences": "Breach exposure of all passwords. Potential regulatory penalties. Reputation damage."
      },
      {
        "id": "b",
        "text": "Implement gradual migrationâ€”rehash to bcrypt when users log in",
        "is_best": true,
        "feedback": "Best practical approach. Users get upgraded on next login. No immediate downtime. Inactive accounts remain at risk but active users protected quickly.",
        "consequences": "Active users protected. Minimal disruption. Gradual improvement."
      },
      {
        "id": "c",
        "text": "Force all users to reset passwords immediately",
        "is_best": false,
        "feedback": "Disruptive to users. Creates support burden. May look like phishing to users. Gradual migration is less disruptive.",
        "consequences": "User frustration. Support costs. Phishing confusion risk."
      },
      {
        "id": "d",
        "text": "Add application-level encryption around MD5 hashes",
        "is_best": false,
        "feedback": "Complexity without addressing root issue. MD5 is still fundamentally weak. Encryption around weak hash doesn't fix collision vulnerability.",
        "consequences": "False sense of security. Added complexity. Doesn't fix core problem."
      }
    ],
    "key_lesson": "Gradual migration is often the most practical approach for password hash upgrades. Rehash to stronger algorithm when users authenticate. Balance security improvement with operational reality."
  },
  "summary": {
    "key_takeaways": [
      "Symmetric (AES): same key, fast for bulk data; Asymmetric (RSA/ECC): key pairs, solves distribution",
      "AES-256 in GCM mode for sensitive data; avoid ECB mode (reveals patterns)",
      "MD5 and SHA-1 are brokenâ€”use SHA-256 or higher",
      "Digital signatures provide integrity, authentication, and non-repudiation",
      "PKI: CA issues certificates, RA verifies identity, certificates have lifecycle",
      "Forward secrecy (ECDHE) protects past sessions if keys compromised"
    ],
    "exam_essentials": [
      "AES = symmetric standard; RSA/ECC = asymmetric",
      "ECB mode is weak; GCM provides encryption + authentication",
      "MD5 (128-bit) and SHA-1 (160-bit) are deprecated",
      "Password hashing: bcrypt, scrypt, Argon2 (not SHA-256)",
      "CA issues certificates; CRL/OCSP for revocation",
      "ECDHE provides forward secrecy"
    ],
    "connection_to_next": "Cryptography protects data confidentiality and integrity. The next lesson explores resilience and recoveryâ€”ensuring systems remain available and data recoverable even when failures occur."
  },
  "related_content": {
    "simulations": [
      "D3-SIM-003"
    ],
    "remediation": [
      "D3-REM-003"
    ],
    "next_lesson": "D3-LESSON-007",
    "previous_lesson": "D3-LESSON-005"
  },
  "subtitle": "The Science of Secrets"
}