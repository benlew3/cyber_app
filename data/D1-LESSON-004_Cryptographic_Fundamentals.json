{
  "lesson_id": "D1-LESSON-004",
  "domain": 1,
  "title": "Cryptographic Fundamentals",
  "subtitle": "The Mathematics of Security: Encryption, Hashing, and Digital Signatures",
  "version": "2.0-enhanced",
  "objectives_covered": [
    "1.4"
  ],
  "estimated_duration": "90-120 minutes (core: 60 min, labs: 30-60 min)",
  "difficulty": "intermediate",
  "prerequisites": [
    "D1-LESSON-002",
    "D1-LESSON-003"
  ],
  "skill_tree": {
    "position": {
      "domain": 1,
      "sequence": 4,
      "tier": "foundation"
    },
    "prerequisites": [
      {
        "lesson_id": "D1-LESSON-002",
        "title": "CIA Triad Fundamentals",
        "why_needed": "Cryptography implements confidentiality (encryption) and integrity (hashing)"
      },
      {
        "lesson_id": "D1-LESSON-003",
        "title": "Authentication Methods",
        "why_needed": "Certificates and digital signatures build on authentication concepts"
      }
    ],
    "unlocks": [
      {
        "lesson_id": "D1-LESSON-005",
        "title": "Zero Trust Architecture",
        "connection": "Zero Trust relies on cryptographic verification for every access"
      },
      {
        "lesson_id": "D3-LESSON-006",
        "title": "Advanced Cryptography",
        "connection": "Deep dive into PKI, key management, and cryptographic implementations"
      }
    ],
    "related_concepts": [
      {
        "topic": "Network Security",
        "lesson": "D3-LESSON-003",
        "relationship": "TLS/SSL secures network communications"
      },
      {
        "topic": "Data Protection",
        "lesson": "D3-LESSON-008",
        "relationship": "Encryption protects data at rest and in transit"
      }
    ],
    "builds_toward": [
      "CompTIA Security+ SY0-701 Certification",
      "CompTIA CySA+ (cryptographic analysis)",
      "CISSP Domain 3: Security Architecture and Engineering"
    ],
    "cascade_learning": {
      "this_lesson_establishes": [
        "Symmetric vs asymmetric encryption distinction",
        "Hash function properties and applications",
        "Digital signature mechanics",
        "PKI and certificate chain of trust",
        "Algorithm selection and deprecation"
      ],
      "builds_on_previous": {
        "D1-LESSON-002": "CIA triad - crypto implements confidentiality and integrity",
        "D1-LESSON-003": "Authentication - certificates enable identity verification"
      },
      "concepts_used_later": {
        "D1-LESSON-005": "Zero Trust uses crypto for continuous verification",
        "D3-LESSON-003": "TLS secures network communications",
        "D3-LESSON-006": "Advanced PKI and key management",
        "D4-LESSON-006": "Data protection through encryption"
      }
    }
  },
  "role_relevance": {
    "soc_analyst": {
      "relevance": "high",
      "percentage_of_job": "20-30%",
      "daily_usage": "Analyze encrypted traffic, verify certificates, investigate crypto failures",
      "specific_tasks": [
        "Investigate certificate warnings and errors",
        "Analyze TLS handshake failures",
        "Detect deprecated cipher usage",
        "Monitor for certificate expiration"
      ],
      "tools_youll_use": [
        "Wireshark (TLS analysis)",
        "SSL Labs",
        "Certificate transparency logs"
      ]
    },
    "incident_responder": {
      "relevance": "high",
      "percentage_of_job": "25-35%",
      "daily_usage": "Analyze ransomware encryption, recover encrypted data, investigate key compromise",
      "specific_tasks": [
        "Assess ransomware encryption strength",
        "Investigate certificate compromise",
        "Analyze cryptographic attack methods",
        "Determine if encrypted data is recoverable"
      ],
      "tools_youll_use": [
        "Forensic tools",
        "Key recovery utilities",
        "Crypto analysis tools"
      ]
    },
    "security_engineer": {
      "relevance": "critical",
      "percentage_of_job": "40-50%",
      "daily_usage": "Implement encryption, manage PKI, configure TLS",
      "specific_tasks": [
        "Deploy and configure TLS on servers",
        "Manage certificate lifecycle",
        "Implement disk and database encryption",
        "Design key management systems",
        "Configure cipher suites"
      ],
      "tools_youll_use": [
        "OpenSSL",
        "Let's Encrypt/certbot",
        "HSMs",
        "Key management systems",
        "PKI platforms"
      ]
    },
    "grc_analyst": {
      "relevance": "high",
      "percentage_of_job": "25-35%",
      "daily_usage": "Audit cryptographic controls, verify compliance requirements",
      "specific_tasks": [
        "Verify encryption meets compliance (PCI-DSS, HIPAA)",
        "Audit key management practices",
        "Assess cryptographic algorithm compliance",
        "Review certificate management procedures"
      ],
      "tools_youll_use": [
        "GRC platforms",
        "Compliance scanners",
        "Audit checklists"
      ]
    },
    "penetration_tester": {
      "relevance": "high",
      "percentage_of_job": "30-40%",
      "daily_usage": "Test cryptographic implementations, crack passwords, find weak ciphers",
      "specific_tasks": [
        "Test for weak cipher suites",
        "Attempt password hash cracking",
        "Identify certificate issues",
        "Test for cryptographic vulnerabilities"
      ],
      "tools_youll_use": [
        "Hashcat",
        "John the Ripper",
        "SSLscan",
        "testssl.sh",
        "Burp Suite"
      ]
    }
  },
  "introduction": {
    "hook": "When you send a message through WhatsApp, enter your credit card online, or connect to your company's VPN, cryptography is working behind the scenes. But what happens when cryptography fails? In 2017, researchers discovered a flaw in RSA key generation that affected millions of devices. Understanding cryptographic principlesâ€”not just using crypto toolsâ€”is essential for recognizing when systems are secure and when they're vulnerable.",
    "learning_goals": [
      "Distinguish between symmetric and asymmetric encryption and their appropriate use cases",
      "Explain how hash functions provide integrity verification",
      "Describe how digital signatures provide authentication, integrity, and non-repudiation",
      "Understand PKI components and certificate chain of trust",
      "Apply appropriate cryptographic solutions to real-world scenarios",
      "Identify deprecated algorithms and current standards"
    ],
    "why_it_matters": {
      "career_impact": "Cryptography is embedded in nearly every security control. You'll configure TLS, evaluate encryption, investigate failures, and recommend algorithms.",
      "business_connection": "Data breaches cost an average of $4.45M (IBM 2023). Proper encryption is often the difference between a breach and a non-event.",
      "exam_relevance": "Expect 8-12 questions covering algorithms, use cases, and implementation considerations."
    },
    "exam_weight": {
      "domain": "Domain 1: General Security Concepts (12%)",
      "estimated_questions": "8-12 questions on cryptography",
      "question_types": [
        "Algorithm selection: 'Which is appropriate for X?'",
        "Deprecated vs current: 'Which should NOT be used?'",
        "Symmetric vs asymmetric: 'Which type is this?'",
        "Hash vs encryption: 'What provides integrity only?'"
      ],
      "high_yield_topics": [
        "AES = symmetric standard; DES/3DES/RC4 = deprecated",
        "RSA/ECC = asymmetric; key size comparisons",
        "MD5/SHA-1 = deprecated; SHA-256/SHA-3 = current",
        "Sign with PRIVATE, verify with PUBLIC",
        "Encrypt with PUBLIC, decrypt with PRIVATE"
      ]
    }
  },
  "sections": [
    {
      "section_id": "D1-L004-S01",
      "title": "Symmetric Encryption: Shared Secret Cryptography",
      "estimated_time": "15 minutes",
      "content": {
        "overview": "Symmetric encryption uses the same key for both encryption and decryption. Like having identical keys for a lockâ€”the sender and receiver must both possess the secret key.",
        "core_concepts": [
          {
            "concept": "How Symmetric Encryption Works",
            "steps": [
              "1. Sender and receiver agree on shared secret key",
              "2. Sender encrypts: Plaintext + Key â†’ Ciphertext",
              "3. Ciphertext transmitted (safe to send over insecure channel)",
              "4. Receiver decrypts: Ciphertext + Key â†’ Plaintext"
            ],
            "key_characteristic": "Same key encrypts AND decrypts",
            "how_it_works": {
              "mechanism": "Mathematical operations transform plaintext into unreadable ciphertext. Without the key, the transformation cannot be reversed.",
              "what_would_happen_if": "If the key is intercepted during exchange, all encrypted communications are compromised. This is the 'key distribution problem' that asymmetric crypto solves."
            }
          },
          {
            "concept": "Block Ciphers",
            "definition": "Encrypt fixed-size blocks of data (e.g., 128 bits at a time)",
            "algorithms": [
              {
                "name": "AES (Advanced Encryption Standard)",
                "status": "CURRENT STANDARD",
                "key_sizes": [
                  "128-bit",
                  "192-bit",
                  "256-bit"
                ],
                "block_size": "128 bits",
                "use_cases": "TLS, disk encryption, VPNs, everywhere",
                "exam_note": "THE answer for symmetric encryption questions"
              },
              {
                "name": "DES (Data Encryption Standard)",
                "status": "DEPRECATED",
                "key_size": "56-bit (inadequate)",
                "block_size": "64 bits",
                "reason_deprecated": "Key too short - can be brute-forced",
                "exam_note": "Know it's deprecated, don't use"
              },
              {
                "name": "3DES (Triple DES)",
                "status": "DEPRECATED (being phased out)",
                "key_size": "112-168 bits effective",
                "note": "Applies DES three times - slower than AES",
                "exam_note": "Legacy, transition to AES"
              }
            ]
          },
          {
            "concept": "Stream Ciphers",
            "definition": "Encrypt one bit or byte at a time",
            "algorithms": [
              {
                "name": "ChaCha20",
                "status": "CURRENT",
                "use_cases": "TLS 1.3, WireGuard VPN, mobile",
                "note": "Fast in software, paired with Poly1305 for authentication"
              },
              {
                "name": "RC4",
                "status": "DEPRECATED",
                "reason": "Known vulnerabilities",
                "exam_note": "Do not use - recognize as insecure"
              }
            ]
          },
          {
            "concept": "Block Cipher Modes",
            "critical_exam_topic": true,
            "modes": [
              {
                "mode": "ECB (Electronic Codebook)",
                "status": "INSECURE - NEVER USE",
                "why_bad": "Identical plaintext blocks = identical ciphertext blocks (patterns visible)",
                "exam_note": "ECB is ALWAYS wrong answer for 'secure encryption'"
              },
              {
                "mode": "CBC (Cipher Block Chaining)",
                "status": "Common but has vulnerabilities",
                "how_works": "Each block XORed with previous ciphertext",
                "note": "Requires IV, vulnerable to padding oracle if misconfigured"
              },
              {
                "mode": "GCM (Galois/Counter Mode)",
                "status": "RECOMMENDED - BEST PRACTICE",
                "key_feature": "Provides encryption AND authentication (AEAD)",
                "use_cases": "TLS 1.3, AES-GCM is the standard choice",
                "exam_note": "GCM = encryption + authentication = AEAD"
              }
            ]
          }
        ],
        "what_would_happen_if": {
          "scenario": "What if you used ECB mode for encrypting images?",
          "consequence": "The encrypted image would show visible patterns from the original. Identical pixel blocks produce identical ciphertext blocks, revealing the image structure. This is why ECB is never used for real encryption.",
          "visual_example": "The famous 'ECB penguin' shows this perfectly - search 'ECB mode penguin' to see why patterns leak through."
        }
      },
      "deep_dive": {
        "title": "Technical Deep Dive: AES Internals",
        "expandable": true,
        "content": {
          "aes_structure": {
            "rounds": {
              "128-bit key": "10 rounds",
              "192-bit key": "12 rounds",
              "256-bit key": "14 rounds"
            },
            "operations_per_round": [
              "SubBytes - byte substitution using S-box",
              "ShiftRows - row-wise permutation",
              "MixColumns - column mixing",
              "AddRoundKey - XOR with round key"
            ]
          },
          "linux_commands": {
            "encrypt_file": "openssl enc -aes-256-cbc -salt -in file.txt -out file.enc",
            "decrypt_file": "openssl enc -aes-256-cbc -d -in file.enc -out file.txt",
            "generate_key": "openssl rand -hex 32"
          }
        }
      },
      "memory_hooks": {
        "common_mistakes": [
          {
            "mistake": "Using DES or 3DES for new applications",
            "why_wrong": "Both are deprecated. DES has 56-bit key (brute-forceable). 3DES is slow and being phased out.",
            "memory_aid": "DES = Don't Even Start. 3DES = 3x as slow, still obsolete."
          },
          {
            "mistake": "Using ECB mode",
            "why_wrong": "Patterns in plaintext appear in ciphertext. Never secure for real data.",
            "memory_aid": "ECB = Every Copy's the same Block (patterns leak)"
          }
        ],
        "mnemonics": [
          "AES = Always Encrypt Securely (current standard)"
        ],
        "analogies": {
          "concept": "Symmetric encryption is like a lockbox with identical keys",
          "explanation": "You and your friend each have the same key. Either key can lock or unlock the box. The challenge: how do you give your friend their copy of the key securely?"
        }
      },
      "key_points": [
        "Symmetric encryption uses the SAME key for encrypt and decrypt",
        "AES is the current standardâ€”use 256-bit keys for high security",
        "DES, 3DES, and RC4 are DEPRECATED",
        "GCM mode provides encryption AND authentication (AEAD)",
        "ECB mode is NEVER secureâ€”patterns leak through"
      ],
      "must_remember_for_exam": [
        {
          "fact": "AES key sizes: 128, 192, 256 bits",
          "why_tested": "Must know AES specifications"
        },
        {
          "fact": "DES = 56-bit = DEPRECATED",
          "why_tested": "Must identify deprecated algorithms"
        },
        {
          "fact": "GCM = AEAD (encryption + authentication)",
          "why_tested": "Best practice cipher mode"
        },
        {
          "fact": "ECB = INSECURE (patterns visible)",
          "why_tested": "Must know which modes are insecure"
        }
      ],
      "knowledge_check": {
        "question": "A security administrator needs to encrypt sensitive database fields. Which algorithm and mode is MOST appropriate?",
        "options": [
          "DES in ECB mode because it's proven over decades",
          "AES-256 in GCM mode because it provides encryption and authentication",
          "3DES in CBC mode because it's still approved",
          "RC4 because stream ciphers are faster"
        ],
        "correct": 1,
        "explanation": "AES-256 in GCM mode provides strong encryption (current standard) AND authentication (AEAD). DES is deprecated. 3DES is being phased out. RC4 has vulnerabilities. ECB is never secure.",
        "wrong_answer_analysis": [
          {
            "option": 0,
            "why_tempting": "DES has long history",
            "why_wrong": "Age doesn't equal security. 56-bit key is breakable. ECB leaks patterns."
          },
          {
            "option": 2,
            "why_tempting": "3DES was a valid transition",
            "why_wrong": "3DES is deprecated and slower than AES"
          },
          {
            "option": 3,
            "why_tempting": "Speed is often desirable",
            "why_wrong": "RC4 has known vulnerabilities and is deprecated"
          }
        ]
      },
      "exam_tips": [
        "AES is symmetric (same key encrypts/decrypts), RSA is asymmetric (public/private keys)",
        "Hashing is ONE-WAY - you cannot decrypt a hash"
      ],
      "career_spotlight": {
        "role": "Cryptography Engineer",
        "daily_tasks": [
          "Implementing encryption in applications",
          "Selecting appropriate algorithms",
          "Managing key rotation",
          "Reviewing cryptographic implementations"
        ],
        "tools_used": [
          "OpenSSL",
          "BouncyCastle",
          "HSMs",
          "Key management systems"
        ],
        "career_path": "Developer → Security Engineer → Cryptography Engineer → Security Architect"
      },
      "real_world_example": {
        "title": "AES Adoption in Government",
        "incident": "In 2001, NIST selected AES (Rijndael) to replace DES as the federal encryption standard after public competition. AES is now used worldwide for encrypting everything from disk drives to classified data.",
        "impact": "Standardized strong encryption globally. Enabled consistent security across industries.",
        "lesson": "Open competitions and peer review produce stronger cryptography than proprietary algorithms."
      },
      "glossary_terms": [
        {
          "term": "AES",
          "definition": "Advanced Encryption Standard - symmetric block cipher using 128/192/256-bit keys",
          "exam_note": "Current standard, replaced DES/3DES"
        },
        {
          "term": "Symmetric Encryption",
          "definition": "Encryption using same key for encryption and decryption",
          "exam_note": "Fast, used for bulk data, key distribution is challenge"
        }
      ]
    },
    {
      "section_id": "D1-L004-S02",
      "title": "Asymmetric Encryption: Public Key Cryptography",
      "estimated_time": "15 minutes",
      "content": {
        "overview": "Asymmetric encryption uses mathematically related key pairs: a public key that can be freely shared and a private key that must be kept secret. What one key encrypts, only the other can decrypt.",
        "core_concepts": [
          {
            "concept": "Two Different Uses of Key Pairs",
            "critical_exam_topic": true,
            "uses": [
              {
                "purpose": "Confidentiality (Encrypting Data)",
                "process": [
                  "Sender obtains recipient's PUBLIC key",
                  "Sender encrypts with recipient's PUBLIC key",
                  "Only recipient's PRIVATE key can decrypt"
                ],
                "memory_aid": "Encrypt with PUBLIC = only private owner can read"
              },
              {
                "purpose": "Digital Signatures (Proving Identity)",
                "process": [
                  "Signer creates hash of message",
                  "Signer encrypts hash with their PRIVATE key",
                  "Anyone can verify with signer's PUBLIC key"
                ],
                "memory_aid": "Sign with PRIVATE = anyone can verify it's really you"
              }
            ],
            "exam_critical": "Encrypt with PUBLIC, decrypt with PRIVATE. Sign with PRIVATE, verify with PUBLIC."
          },
          {
            "concept": "Common Asymmetric Algorithms",
            "algorithms": [
              {
                "name": "RSA",
                "full_name": "Rivest-Shamir-Adleman",
                "status": "CURRENT (but large keys needed)",
                "based_on": "Difficulty of factoring large prime numbers",
                "key_sizes": [
                  "2048-bit minimum",
                  "4096-bit recommended"
                ],
                "capabilities": [
                  "Encryption",
                  "Digital signatures",
                  "Key exchange"
                ],
                "exam_note": "Most widely used asymmetric algorithm"
              },
              {
                "name": "ECC (Elliptic Curve Cryptography)",
                "status": "CURRENT (growing adoption)",
                "based_on": "Elliptic curve mathematics",
                "key_advantage": "Smaller keys = same security",
                "comparison": "256-bit ECC â‰ˆ 3072-bit RSA security",
                "variants": [
                  "ECDSA (signatures)",
                  "ECDH (key exchange)"
                ],
                "exam_note": "More efficient than RSA, especially for mobile/IoT"
              },
              {
                "name": "Diffie-Hellman (DH)",
                "status": "CURRENT",
                "purpose": "KEY EXCHANGE ONLY - not encryption",
                "how_works": "Two parties establish shared secret over insecure channel",
                "variants": [
                  "DHE (ephemeral)",
                  "ECDH (elliptic curve)"
                ],
                "exam_note": "DH = key exchange, NOT encryption"
              }
            ]
          },
          {
            "concept": "Hybrid Encryption",
            "why_needed": "Asymmetric is too slow for large data",
            "how_it_works": [
              "1. Generate random symmetric key (session key)",
              "2. Encrypt DATA with fast symmetric (AES)",
              "3. Encrypt the symmetric KEY with slow asymmetric (RSA/ECC)",
              "4. Send encrypted data + encrypted key",
              "5. Recipient decrypts key with private key",
              "6. Recipient decrypts data with symmetric key"
            ],
            "real_world": "This is exactly how TLS, PGP, and most encryption works"
          },
          {
            "concept": "Perfect Forward Secrecy (PFS)",
            "definition": "Using ephemeral (temporary) keys for each session",
            "benefit": "If long-term private key is later compromised, past sessions remain secure",
            "how_achieved": "DHE or ECDHE cipher suites",
            "exam_note": "PFS protects PAST sessions from FUTURE key compromise"
          }
        ],
        "what_would_happen_if": {
          "scenario": "What if a server's private key is stolen but they used PFS?",
          "consequence": "Past recorded sessions are STILL SECURE. Each session used temporary (ephemeral) keys that were discarded after use. The attacker can only compromise future sessions (until the key is replaced), not historical data.",
          "without_pfs": "Without PFS, the attacker could decrypt ALL past recorded traffic. This is why 'harvest now, decrypt later' attacks target non-PFS connections."
        }
      },
      "memory_hooks": {
        "visual_aid": {
          "encryption": "Think of a mailbox: Anyone can PUT mail in (public key encrypts), only you can TAKE mail out (private key decrypts)",
          "signatures": "Think of your handwritten signature: Only YOU can sign (private key), anyone can VERIFY it's your signature (public key)"
        },
        "common_mistakes": [
          {
            "mistake": "Confusing encryption and signing key usage",
            "why_wrong": "They're opposite! Encryption: publicâ†’private. Signing: privateâ†’public.",
            "memory_aid": "Encryption hides (public puts in, private takes out). Signing proves (private creates, public verifies)."
          },
          {
            "mistake": "Thinking Diffie-Hellman encrypts data",
            "why_wrong": "DH only establishes a shared secret. You still need AES or similar to actually encrypt.",
            "memory_aid": "DH = Deals out the Handshake (key exchange only)"
          }
        ],
        "mnemonics": [
          "PUBLIC for Privacy (encrypt), PRIVATE for Proof (sign)"
        ]
      },
      "key_points": [
        "Asymmetric uses key PAIRS: public encrypts, private decrypts",
        "For signatures: private signs, public verifies (OPPOSITE of encryption)",
        "RSA is common but ECC provides same security with smaller keys",
        "Diffie-Hellman is KEY EXCHANGE, not encryption",
        "Hybrid encryption: symmetric for data, asymmetric for key exchange"
      ],
      "must_remember_for_exam": [
        {
          "fact": "Encrypt with PUBLIC, decrypt with PRIVATE",
          "why_tested": "Core asymmetric concept"
        },
        {
          "fact": "Sign with PRIVATE, verify with PUBLIC",
          "why_tested": "Opposite of encryption - commonly confused"
        },
        {
          "fact": "ECC 256-bit â‰ˆ RSA 3072-bit security",
          "why_tested": "Key size comparison question"
        },
        {
          "fact": "PFS = ephemeral keys = protects past sessions",
          "why_tested": "Forward secrecy concept"
        }
      ],
      "knowledge_check": {
        "question": "A security architect wants to ensure that if the company's private key is stolen next year, attackers cannot decrypt traffic captured today. Which feature provides this?",
        "options": [
          "AES-256 encryption",
          "RSA 4096-bit keys",
          "Perfect Forward Secrecy using ECDHE",
          "Certificate pinning"
        ],
        "correct": 2,
        "explanation": "PFS using ECDHE generates unique session keys for each connection. Even if the long-term key is later compromised, past session keys cannot be recoveredâ€”they were discarded.",
        "wrong_answer_analysis": [
          {
            "option": 0,
            "why_tempting": "Stronger encryption seems protective",
            "why_wrong": "Key strength doesn't address key compromise"
          },
          {
            "option": 1,
            "why_tempting": "Larger keys are harder to break",
            "why_wrong": "If the key is stolen, size doesn't matter"
          },
          {
            "option": 3,
            "why_tempting": "Certificate security is important",
            "why_wrong": "Pinning prevents fake certs, not key theft"
          }
        ]
      },
      "exam_tips": [
        "AES is symmetric (same key encrypts/decrypts), RSA is asymmetric (public/private keys)",
        "Hashing is ONE-WAY - you cannot decrypt a hash"
      ],
      "deep_dive": [
        {
          "title": "RSA vs ECC",
          "content": "RSA (Rivest-Shamir-Adleman) uses factoring large primes - well understood but requires large keys (2048+ bits). ECC (Elliptic Curve Cryptography) uses elliptic curve math - smaller keys provide equivalent security (256-bit ECC ≈ 3072-bit RSA). ECC preferred for: Mobile/IoT (less computation), TLS (faster handshakes). RSA still used: Legacy compatibility, simpler implementation. Quantum threat: Both vulnerable to quantum computers - post-quantum algorithms being standardized."
        }
      ],
      "career_spotlight": {
        "role": "PKI Administrator",
        "daily_tasks": [
          "Managing certificate authorities",
          "Issuing and revoking certificates",
          "Maintaining certificate policies",
          "Troubleshooting certificate issues"
        ],
        "tools_used": [
          "Microsoft CA",
          "OpenSSL",
          "Venafi",
          "DigiCert"
        ],
        "career_path": "Systems Admin → PKI Admin → PKI Architect → Security Architect"
      },
      "real_world_example": {
        "title": "DigiNotar CA Compromise (2011)",
        "incident": "Attackers compromised DigiNotar CA and issued fraudulent certificates for Google, Yahoo, and other domains. Used to intercept Iranian dissidents' communications.",
        "impact": "DigiNotar went bankrupt. Led to Certificate Transparency requirements. Showed PKI trust model vulnerabilities.",
        "lesson": "CAs are critical trust anchors. CA compromise enables widespread attacks. Certificate Transparency helps detect fraudulent issuance."
      },
      "glossary_terms": [
        {
          "term": "RSA",
          "definition": "Asymmetric algorithm based on difficulty of factoring large prime products",
          "exam_note": "Common for key exchange and digital signatures"
        },
        {
          "term": "PKI",
          "definition": "Public Key Infrastructure - system for managing digital certificates and public keys",
          "exam_note": "Enables trust in public key ownership"
        }
      ]
    },
    {
      "section_id": "D1-L004-S03",
      "title": "Hash Functions and Integrity",
      "estimated_time": "15 minutes",
      "content": {
        "overview": "Hash functions are one-way mathematical functions that convert input of any size into a fixed-size output. They're fundamental to ensuring data integrityâ€”verifying that data hasn't been modified.",
        "core_concepts": [
          {
            "concept": "Hash Function Properties",
            "properties": [
              {
                "property": "Deterministic",
                "meaning": "Same input ALWAYS produces same output"
              },
              {
                "property": "Fixed Output Size",
                "meaning": "Any input size â†’ same hash length (e.g., SHA-256 = 256 bits always)"
              },
              {
                "property": "One-Way (Pre-image Resistance)",
                "meaning": "Cannot reverse hash to find original input"
              },
              {
                "property": "Collision Resistance",
                "meaning": "Extremely difficult to find two inputs with same hash"
              },
              {
                "property": "Avalanche Effect",
                "meaning": "Small input change â†’ dramatically different hash"
              }
            ]
          },
          {
            "concept": "Hash Algorithms",
            "algorithms": [
              {
                "name": "MD5",
                "output": "128 bits",
                "status": "BROKEN - DO NOT USE for security",
                "reason": "Collision attacks demonstrated",
                "still_used_for": "Non-security checksums only"
              },
              {
                "name": "SHA-1",
                "output": "160 bits",
                "status": "DEPRECATED",
                "reason": "Collision attacks demonstrated (2017)",
                "note": "Being phased out of security applications"
              },
              {
                "name": "SHA-256 (SHA-2 family)",
                "output": "256 bits",
                "status": "CURRENT STANDARD",
                "use_cases": "TLS, code signing, blockchain, general security",
                "family": "Also SHA-384, SHA-512"
              },
              {
                "name": "SHA-3",
                "output": "Various (256, 384, 512 bits)",
                "status": "CURRENT (newest)",
                "note": "Different internal structure than SHA-2 (Keccak)",
                "purpose": "Alternative if SHA-2 weaknesses found"
              }
            ]
          },
          {
            "concept": "Password Hashing",
            "critical_distinction": true,
            "wrong_approach": {
              "method": "Plain SHA-256 for passwords",
              "why_wrong": "SHA-256 is too FAST. GPUs can compute billions per second.",
              "vulnerability": "Brute force becomes practical"
            },
            "correct_approach": {
              "algorithms": [
                "bcrypt",
                "scrypt",
                "Argon2 (recommended)"
              ],
              "why_correct": "Intentionally SLOW - makes brute force impractical",
              "additional_requirement": "Unique SALT per password"
            },
            "salt_explained": {
              "what": "Random value added to password before hashing",
              "why": "Same password â†’ different hash (defeats rainbow tables)",
              "must_be": "Unique per password, stored alongside hash"
            }
          },
          {
            "concept": "HMAC (Hash-based Message Authentication Code)",
            "definition": "Hash function combined with secret key",
            "provides": "Integrity AND authenticity (not just integrity)",
            "how_works": [
              "Combine key with message in specific way",
              "Hash the combination",
              "Recipient repeats with shared key",
              "Match = integrity + authenticity confirmed"
            ],
            "example": "HMAC-SHA256"
          }
        ],
        "what_would_happen_if": {
          "scenario": "What if you stored passwords with unsalted MD5?",
          "consequence": "1) Rainbow table attack recovers most passwords in seconds. 2) Identical passwords have identical hashes (visible in breach). 3) MD5 is fastâ€”brute force is feasible. 4) MD5 has collisionsâ€”different passwords could match same hash.",
          "correct_approach": "Use Argon2 with unique salt per password. Slow algorithm + unique salt = attackers can't precompute and must brute force each password individually (infeasible)."
        }
      },
      "deep_dive": {
        "title": "Technical Deep Dive: Linux Hash Commands",
        "expandable": true,
        "content": {
          "commands": [
            {
              "command": "echo -n 'test' | sha256sum",
              "purpose": "Hash a string with SHA-256"
            },
            {
              "command": "sha256sum file.txt",
              "purpose": "Hash a file"
            },
            {
              "command": "echo -n 'test' | md5sum",
              "purpose": "MD5 hash (checksums only!)"
            },
            {
              "command": "openssl dgst -sha256 file.txt",
              "purpose": "OpenSSL hash"
            }
          ],
          "password_hashing": {
            "note": "For password storage, use proper tools:",
            "example": "htpasswd uses bcrypt by default in modern Apache",
            "python": "from passlib.hash import argon2; argon2.hash('password')"
          }
        }
      },
      "memory_hooks": {
        "common_mistakes": [
          {
            "mistake": "Using SHA-256 for password hashing",
            "why_wrong": "SHA-256 is designed for speed. Passwords need slow hashing.",
            "memory_aid": "Fast hash = fast crack. For passwords, SLOW = SECURE (bcrypt, Argon2)."
          },
          {
            "mistake": "Thinking encryption and hashing are the same",
            "why_wrong": "Encryption is reversible (with key). Hashing is one-way (cannot reverse).",
            "memory_aid": "Encryption = locked box (can unlock). Hash = meat grinder (can't un-grind)."
          }
        ],
        "mnemonics": [
          "MD5 = Mostly Defunct. SHA-1 = Should Have been Abandoned. SHA-256 = Secure Hash Always."
        ]
      },
      "key_points": [
        "Hash functions are ONE-WAYâ€”cannot reverse to find original",
        "MD5 = BROKEN, SHA-1 = DEPRECATED, SHA-256/SHA-3 = CURRENT",
        "Password hashing needs SLOW algorithms: bcrypt, scrypt, Argon2",
        "SALT is unique random value per passwordâ€”defeats rainbow tables",
        "HMAC = hash + key = integrity AND authenticity"
      ],
      "must_remember_for_exam": [
        {
          "fact": "MD5 = broken, SHA-1 = deprecated, SHA-256 = current",
          "why_tested": "Must identify deprecated algorithms"
        },
        {
          "fact": "Passwords use bcrypt/scrypt/Argon2 (slow), NOT SHA-256",
          "why_tested": "Common security question"
        },
        {
          "fact": "Salt must be UNIQUE per password",
          "why_tested": "Salt implementation detail"
        },
        {
          "fact": "Hashing = one-way; Encryption = two-way (reversible with key)",
          "why_tested": "Fundamental distinction"
        }
      ],
      "knowledge_check": {
        "question": "An organization stores user passwords by hashing them with SHA-256. A security auditor identifies this as inadequate. What is the PRIMARY concern?",
        "options": [
          "SHA-256 has known collision vulnerabilities",
          "SHA-256 is too fast, making brute-force attacks feasible",
          "SHA-256 produces fixed-length output, making passwords guessable",
          "SHA-256 is deprecated and should be replaced with SHA-3"
        ],
        "correct": 1,
        "explanation": "SHA-256 is cryptographically sound but TOO FAST for passwords. Attackers can compute billions of hashes per second. Password hashing needs intentionally slow algorithms (bcrypt, Argon2) that make brute force computationally expensive.",
        "wrong_answer_analysis": [
          {
            "option": 0,
            "why_tempting": "MD5 has collision issues, maybe SHA-256 too?",
            "why_wrong": "SHA-256 has no known collision vulnerabilities"
          },
          {
            "option": 2,
            "why_tempting": "Fixed output sounds limiting",
            "why_wrong": "Fixed output is a feature, not a weakness"
          },
          {
            "option": 3,
            "why_tempting": "Newer algorithms might be required",
            "why_wrong": "SHA-256 is not deprecatedâ€”it's just wrong for passwords specifically"
          }
        ]
      },
      "exam_tips": [
        "Focus on understanding concepts, not memorizing details",
        "Expect scenario-based questions that test application of knowledge"
      ],
      "career_spotlight": {
        "role": "Digital Forensics Analyst",
        "daily_tasks": [
          "Preserving evidence integrity with hashes",
          "Verifying file authenticity",
          "Detecting data tampering",
          "Chain of custody documentation"
        ],
        "tools_used": [
          "FTK",
          "EnCase",
          "HashCalc",
          "md5sum/sha256sum"
        ],
        "career_path": "IT Support → Forensics Analyst → Senior Analyst → Forensics Manager"
      },
      "real_world_example": {
        "title": "MD5 Collision in Flame Malware",
        "incident": "Flame malware used MD5 collision attack against Windows Update to create fraudulent Microsoft certificate, allowing it to spread via Windows Update.",
        "impact": "Demonstrated real-world exploitation of MD5 weakness. Microsoft had to revoke certificates and patch Windows Update.",
        "lesson": "Weak hash algorithms have real consequences. MD5 should not be used for security purposes. Always use SHA-256 or stronger."
      },
      "glossary_terms": [
        {
          "term": "Hash Function",
          "definition": "One-way function producing fixed-size output from variable input",
          "exam_note": "Used for integrity, not encryption - cannot reverse"
        },
        {
          "term": "SHA-256",
          "definition": "Secure Hash Algorithm producing 256-bit digest",
          "exam_note": "Current recommended standard, part of SHA-2 family"
        }
      ]
    },
    {
      "section_id": "D1-L004-S04",
      "title": "Digital Signatures and Certificates",
      "estimated_time": "15 minutes",
      "content": {
        "overview": "Digital signatures provide authentication, integrity, AND non-repudiation. Combined with certificates, they form the foundation of trust on the internet.",
        "core_concepts": [
          {
            "concept": "Digital Signature Process",
            "signing": [
              "1. Create hash of the document (creates small, fixed-size digest)",
              "2. Encrypt the hash with sender's PRIVATE key",
              "3. Attach encrypted hash (signature) to document",
              "4. Send document + signature"
            ],
            "verification": [
              "1. Separate signature from document",
              "2. Decrypt signature with sender's PUBLIC key â†’ Original hash",
              "3. Hash the received document â†’ Calculated hash",
              "4. Compare: If hashes match â†’ Valid signature"
            ],
            "what_it_proves": [
              {
                "property": "Authentication",
                "proof": "Only private key holder could create signature"
              },
              {
                "property": "Integrity",
                "proof": "Any modification changes hash, invalidating signature"
              },
              {
                "property": "Non-Repudiation",
                "proof": "Signer cannot deny signing (if key wasn't compromised)"
              }
            ]
          },
          {
            "concept": "Digital Certificates (X.509)",
            "purpose": "Bind public keys to identities, enabling trust",
            "contents": [
              "Subject (identity of certificate holder)",
              "Public key of the subject",
              "Issuer (CA that issued it)",
              "Validity period (not before/after dates)",
              "Serial number (unique identifier)",
              "CA's signature (CA signs the certificate)"
            ],
            "types": [
              {
                "type": "DV (Domain Validation)",
                "validates": "Domain control only",
                "trust_level": "Low"
              },
              {
                "type": "OV (Organization Validation)",
                "validates": "Organization identity",
                "trust_level": "Medium"
              },
              {
                "type": "EV (Extended Validation)",
                "validates": "Extensive identity verification",
                "trust_level": "High"
              },
              {
                "type": "Wildcard",
                "scope": "Domain + all subdomains (*.example.com)"
              },
              {
                "type": "SAN",
                "scope": "Multiple specific domains in one cert"
              }
            ]
          },
          {
            "concept": "PKI (Public Key Infrastructure)",
            "components": [
              {
                "component": "Certificate Authority (CA)",
                "role": "Issues and signs certificates"
              },
              {
                "component": "Registration Authority (RA)",
                "role": "Verifies identity before issuance"
              },
              {
                "component": "Certificate Repository",
                "role": "Stores and distributes certificates"
              },
              {
                "component": "CRL (Certificate Revocation List)",
                "role": "List of revoked certificates"
              },
              {
                "component": "OCSP Responder",
                "role": "Real-time certificate status checking"
              }
            ],
            "chain_of_trust": [
              {
                "level": "Root CA",
                "description": "Self-signed, trust anchor (in browsers/OS)"
              },
              {
                "level": "Intermediate CA",
                "description": "Signed by root, issues end-entity certs"
              },
              {
                "level": "End-Entity Certificate",
                "description": "The actual server/user certificate"
              }
            ]
          },
          {
            "concept": "Revocation Checking",
            "methods": [
              {
                "method": "CRL (Certificate Revocation List)",
                "how_works": "Periodic list published by CA",
                "limitation": "May be stale between updates"
              },
              {
                "method": "OCSP (Online Certificate Status Protocol)",
                "how_works": "Real-time query to CA",
                "advantage": "Current status",
                "variant": "OCSP stapling - server includes response, reducing latency"
              }
            ]
          }
        ],
        "what_would_happen_if": {
          "scenario": "What if a Certificate Authority is compromised?",
          "consequence": "Attackers could issue valid certificates for ANY domain. Browsers would trust these fake certificates, enabling man-in-the-middle attacks against all websites. This is why CA compromise is catastrophicâ€”DigiNotar went bankrupt after their 2011 breach.",
          "protections": "Certificate Transparency logs help detect rogue certificates. CAA records limit which CAs can issue for your domain."
        }
      },
      "memory_hooks": {
        "common_mistakes": [
          {
            "mistake": "Confusing signing and encrypting key usage",
            "why_wrong": "They're OPPOSITE. Encrypt: publicâ†’private. Sign: privateâ†’public.",
            "memory_aid": "Signing = proving it's YOU (private). Encrypting = hiding from OTHERS (public)."
          },
          {
            "mistake": "Thinking CRL and OCSP are the same",
            "why_wrong": "CRL is periodic (may be stale). OCSP is real-time (current status).",
            "memory_aid": "CRL = Comes out Regularly Later (periodic). OCSP = Online Status Check Protocol (real-time)."
          }
        ],
        "mnemonics": [
          "SIGN with private (Secret creates signature), VERIFY with public (Everyone can check)"
        ]
      },
      "key_points": [
        "Digital signatures: hash message, encrypt hash with PRIVATE key",
        "Verification: decrypt with PUBLIC key, compare hashes",
        "Signatures provide authentication, integrity, AND non-repudiation",
        "Certificates bind public keys to identities via CA signatures",
        "Certificate chain: End-entity â†’ Intermediate CA â†’ Root CA (trust anchor)"
      ],
      "must_remember_for_exam": [
        {
          "fact": "Sign with PRIVATE, verify with PUBLIC",
          "why_tested": "Opposite of encryption - commonly confused"
        },
        {
          "fact": "Digital signatures = authentication + integrity + non-repudiation",
          "why_tested": "Must know all three properties"
        },
        {
          "fact": "CRL = periodic list; OCSP = real-time check",
          "why_tested": "Revocation method comparison"
        }
      ],
      "knowledge_check": {
        "question": "An attacker obtains a company's digital certificate but NOT the private key. What can the attacker do?",
        "options": [
          "Decrypt all traffic encrypted with the certificate",
          "Create valid digital signatures impersonating the company",
          "Verify signatures from the legitimate certificate holder",
          "Issue new certificates under the company's identity"
        ],
        "correct": 2,
        "explanation": "With only the certificate (public key), an attacker can only VERIFY signaturesâ€”this is a public operation. They cannot decrypt (need private), sign (need private), or issue certs (need CA's private key).",
        "wrong_answer_analysis": [
          {
            "option": 0,
            "why_tempting": "Certificates relate to encryption",
            "why_wrong": "Decryption requires private key, not public"
          },
          {
            "option": 1,
            "why_tempting": "Certificate proves identity",
            "why_wrong": "Signing requires private key"
          },
          {
            "option": 3,
            "why_tempting": "Certificates are used for issuing",
            "why_wrong": "Only CAs issue certs, using CA's private key"
          }
        ]
      },
      "exam_tips": [
        "Memorize the three authentication factors: Something you know, have, are",
        "Understand MFA requires factors from DIFFERENT categories"
      ],
      "deep_dive": [
        {
          "title": "Certificate Chain Validation",
          "content": "Browser validates server certificate by: 1) Check certificate is not expired 2) Check certificate is not revoked (CRL/OCSP) 3) Check certificate is for correct domain 4) Verify signature using issuing CA's public key 5) Repeat for intermediate CAs up to trusted root. If any check fails, browser shows warning. Extended Validation (EV) requires additional verification of organization identity."
        }
      ],
      "career_spotlight": {
        "role": "Code Signing Administrator",
        "daily_tasks": [
          "Managing code signing certificates",
          "Signing software releases",
          "Securing private keys",
          "Maintaining signing infrastructure"
        ],
        "tools_used": [
          "SignTool",
          "Jarsigner",
          "GPG",
          "HSMs"
        ],
        "career_path": "Developer → Release Engineer → Code Signing Admin → Security Engineer"
      },
      "real_world_example": {
        "title": "Stuxnet's Stolen Certificates",
        "incident": "Stuxnet used stolen code-signing certificates from Realtek and JMicron to sign its drivers, bypassing Windows driver signature requirements.",
        "impact": "First known nation-state use of stolen code-signing certs. Highlighted code-signing key protection importance.",
        "lesson": "Code signing keys are high-value targets. Require HSM storage and strict access controls."
      },
      "glossary_terms": [
        {
          "term": "Digital Signature",
          "definition": "Cryptographic proof of authenticity created with signer's private key",
          "exam_note": "Provides non-repudiation - signer cannot deny signing"
        },
        {
          "term": "Certificate",
          "definition": "Document binding public key to identity, signed by CA",
          "exam_note": "X.509 is standard format"
        }
      ]
    },
    {
      "section_id": "D1-L004-S05",
      "title": "Cryptographic Applications and Best Practices",
      "estimated_time": "12 minutes",
      "content": {
        "overview": "Understanding how cryptographic primitives combine into real-world systems is essential for implementation and evaluation.",
        "core_concepts": [
          {
            "concept": "TLS (Transport Layer Security)",
            "purpose": "Secures communication over networks (HTTPS, email, VPN)",
            "versions": [
              {
                "version": "TLS 1.0, 1.1",
                "status": "DEPRECATED - vulnerabilities"
              },
              {
                "version": "TLS 1.2",
                "status": "Current minimum - widely used"
              },
              {
                "version": "TLS 1.3",
                "status": "Current best - faster, more secure"
              }
            ],
            "tls_1_3_improvements": [
              "Removed vulnerable cipher suites",
              "Only PFS cipher suites (DHE/ECDHE required)",
              "Fewer round trips (faster handshake)",
              "More of handshake encrypted"
            ]
          },
          {
            "concept": "Email Security",
            "methods": [
              {
                "method": "S/MIME",
                "trust_model": "Certificate-based (PKI)",
                "use_case": "Enterprise email",
                "requires": "Certificates from CA"
              },
              {
                "method": "PGP/GPG",
                "trust_model": "Web of trust (peer signing)",
                "use_case": "Personal/open source",
                "requires": "Users sign each other's keys"
              }
            ],
            "exam_distinction": "S/MIME = certificates/PKI; PGP = web of trust"
          },
          {
            "concept": "Disk Encryption",
            "types": [
              {
                "type": "Full Disk Encryption (FDE)",
                "protects": "Entire drive including OS",
                "products": [
                  "BitLocker (Windows)",
                  "FileVault (macOS)",
                  "LUKS (Linux)"
                ],
                "key_protection": "TPM, password, USB key"
              },
              {
                "type": "File/Folder Encryption",
                "protects": "Specific files or containers",
                "products": [
                  "EFS (Windows)",
                  "VeraCrypt"
                ],
                "advantage": "More granular control"
              }
            ]
          },
          {
            "concept": "Cryptographic Best Practices",
            "guidelines": [
              {
                "category": "Algorithm Selection",
                "do": "AES-256, RSA 4096, SHA-256, ECDHE",
                "dont": "DES, 3DES, MD5, SHA-1, RC4"
              },
              {
                "category": "Key Management",
                "practices": [
                  "Generate with proper entropy (true random)",
                  "Protect private keys (HSM, secure storage)",
                  "Implement rotation and expiration",
                  "Destroy keys securely when done"
                ]
              },
              {
                "category": "Implementation",
                "practices": [
                  "Use well-tested libraries (don't roll your own)",
                  "Keep libraries updated",
                  "Proper random number generation (CSPRNG)",
                  "Secure key storage (not in code)"
                ]
              }
            ]
          }
        ]
      },
      "key_points": [
        "TLS 1.2 is minimum; TLS 1.3 is preferred (PFS required)",
        "S/MIME uses certificates; PGP uses web of trust",
        "Full disk encryption: BitLocker (Windows), FileVault (macOS), LUKS (Linux)",
        "Never implement your own cryptoâ€”use tested libraries",
        "Plan for crypto agilityâ€”ability to change algorithms"
      ],
      "must_remember_for_exam": [
        {
          "fact": "TLS 1.0/1.1 = deprecated; TLS 1.2 = minimum; TLS 1.3 = best",
          "why_tested": "Protocol version selection"
        },
        {
          "fact": "TLS 1.3 requires PFS (DHE/ECDHE)",
          "why_tested": "Key protocol difference"
        },
        {
          "fact": "S/MIME = PKI; PGP = web of trust",
          "why_tested": "Email security comparison"
        }
      ],
      "knowledge_check": {
        "question": "A security administrator is configuring a web server. Which TLS configuration is BEST practice?",
        "options": [
          "TLS 1.0 with AES-128-CBC for maximum compatibility",
          "TLS 1.2 with RSA key exchange and AES-256-CBC",
          "TLS 1.3 with ECDHE key exchange and AES-256-GCM",
          "TLS 1.2 with 3DES for legacy support"
        ],
        "correct": 2,
        "explanation": "TLS 1.3 with ECDHE (PFS) and AES-256-GCM (AEAD) is best practice. TLS 1.0 is deprecated. RSA key exchange lacks PFS. 3DES is deprecated.",
        "wrong_answer_analysis": [
          {
            "option": 0,
            "why_tempting": "Compatibility is valuable",
            "why_wrong": "TLS 1.0 is deprecated and vulnerable"
          },
          {
            "option": 1,
            "why_tempting": "TLS 1.2 and AES-256 are good",
            "why_wrong": "RSA key exchange lacks PFS; CBC has issues vs GCM"
          },
          {
            "option": 3,
            "why_tempting": "Legacy support may be needed",
            "why_wrong": "3DES is deprecated"
          }
        ]
      },
      "exam_tips": [
        "Symmetric encryption is faster, used for bulk data",
        "Asymmetric encryption solves key distribution problem"
      ],
      "memory_hooks": {
        "mnemonics": [
          "TLS for Transit, AES for At-rest, PKI for People"
        ],
        "analogies": [
          "Choosing encryption is like choosing locks - padlock for gym locker, deadbolt for front door"
        ],
        "common_mistakes": [
          "Using encryption without proper key management"
        ]
      },
      "deep_dive": [
        {
          "title": "Perfect Forward Secrecy",
          "content": "PFS ensures past sessions remain secure even if long-term keys are compromised. Without PFS: If server's private key is stolen, all past TLS sessions can be decrypted (if captured). With PFS (DHE/ECDHE): Session keys are derived from ephemeral key exchange, not server's private key. Past sessions remain protected. TLS 1.3 requires PFS. Best practice: Enable PFS cipher suites."
        }
      ],
      "career_spotlight": {
        "role": "Application Security Architect",
        "daily_tasks": [
          "Designing secure application architectures",
          "Selecting appropriate cryptographic controls",
          "Reviewing security designs",
          "Mentoring development teams"
        ],
        "tools_used": [
          "Threat modeling tools",
          "Security frameworks",
          "Crypto libraries documentation"
        ],
        "career_path": "Developer → Security Engineer → AppSec Engineer → Security Architect"
      },
      "real_world_example": {
        "title": "Heartbleed and Key Compromise",
        "incident": "Heartbleed (CVE-2014-0160) allowed reading server memory, potentially including private keys. Sites using PFS had past sessions protected even if keys were stolen.",
        "impact": "Mass certificate revocation and reissuance. Highlighted importance of PFS.",
        "lesson": "Always enable PFS. Assume key compromise is possible and design for it."
      },
      "glossary_terms": [
        {
          "term": "TLS",
          "definition": "Transport Layer Security - protocol for encrypted communications",
          "exam_note": "Use TLS 1.2+ (1.3 preferred), deprecate older versions"
        },
        {
          "term": "PFS",
          "definition": "Perfect Forward Secrecy - ensures past sessions secure even if keys compromised",
          "exam_note": "Achieved with ephemeral key exchange (DHE/ECDHE)"
        }
      ]
    }
  ],
  "hands_on_labs": {
    "browser_labs": [
      {
        "lab_id": "lab-crypto-classifier",
        "title": "Cryptographic Algorithm Classifier",
        "type": "drag_and_drop",
        "difficulty": "beginner",
        "estimated_time": "10 minutes",
        "description": "Classify algorithms as symmetric/asymmetric/hash and current/deprecated."
      },
      {
        "lab_id": "lab-hash-demo",
        "title": "Hash Function Demonstrator",
        "type": "interactive_demo",
        "difficulty": "beginner",
        "estimated_time": "10 minutes",
        "description": "See how hash functions produce different outputs for tiny input changes."
      },
      {
        "lab_id": "lab-cert-chain",
        "title": "Certificate Chain Validator",
        "type": "scenario_analysis",
        "difficulty": "intermediate",
        "estimated_time": "15 minutes",
        "description": "Trace certificate chains and identify trust issues."
      }
    ],
    "external_labs": [
      {
        "resource": "TryHackMe",
        "lab_name": "Cryptography Basics",
        "url": "https://tryhackme.com/room/cryptographyintro",
        "cost": "Free",
        "estimated_time": "2 hours",
        "role_relevance": [
          "security_engineer",
          "penetration_tester"
        ]
      },
      {
        "resource": "SSL Labs",
        "lab_name": "SSL Server Test",
        "url": "https://www.ssllabs.com/ssltest/",
        "cost": "Free",
        "estimated_time": "30 minutes",
        "description": "Analyze real websites for TLS configuration quality.",
        "role_relevance": [
          "security_engineer",
          "soc_analyst"
        ]
      }
    ],
    "tools_introduction": [
      {
        "tool": "OpenSSL",
        "category": "Cryptographic Toolkit",
        "purpose": "Encryption, hashing, certificate management",
        "key_commands": [
          "openssl enc - encrypt/decrypt files",
          "openssl dgst - create hashes",
          "openssl genrsa - generate RSA keys",
          "openssl x509 - certificate operations"
        ],
        "role_relevance": [
          "security_engineer",
          "penetration_tester"
        ]
      },
      {
        "tool": "Hashcat",
        "category": "Password Cracking",
        "purpose": "Test password hash strength",
        "role_relevance": [
          "penetration_tester"
        ],
        "note": "Only use with authorization"
      }
    ]
  },
  "summary": {
    "key_takeaways": [
      "Symmetric (same key) is fast; AES-256 is the standard",
      "Asymmetric (key pair) solves key distribution; RSA and ECC are common",
      "Hybrid encryption: symmetric for data, asymmetric for key exchange",
      "Hash functions are one-way; SHA-256/SHA-3 are current standards",
      "Digital signatures provide authentication, integrity, AND non-repudiation",
      "Certificates bind public keys to identities via CA chain of trust"
    ],
    "exam_essentials": [
      "AES = symmetric standard; DES/3DES/RC4 = deprecated",
      "RSA/ECC = asymmetric; DH = key exchange only",
      "Encrypt with PUBLIC, decrypt with PRIVATE",
      "Sign with PRIVATE, verify with PUBLIC",
      "MD5/SHA-1 = deprecated; SHA-256/SHA-3 = current",
      "Passwords: slow hashes (bcrypt/Argon2) with unique salt"
    ],
    "connection_to_next": "With cryptographic foundations established, the next lesson explores Zero Trust Architectureâ€”a modern security model that applies cryptographic verification to every access request, treating all networks as potentially hostile."
  },
  "related_content": {
    "simulations": [
      "D1-SIM-003"
    ],
    "remediation": [
      "D1-REM-003"
    ],
    "next_lesson": "D1-LESSON-005",
    "previous_lesson": "D1-LESSON-003"
  },
  "hands_on_activity": {
    "title": "Cryptographic Algorithm Selection",
    "objective": "Select appropriate cryptographic algorithms for different use cases",
    "scenario": "As a security engineer at SecureData Inc., you need to recommend cryptographic solutions for various business needs.",
    "steps": [
      "Identify the security requirement (confidentiality, integrity, authentication)",
      "Consider performance requirements and constraints",
      "Select appropriate algorithm type and key size",
      "Document any implementation considerations"
    ],
    "exercises": [
      {
        "requirement": "Encrypt customer data at rest in database",
        "recommended": "AES-256",
        "type": "Symmetric encryption",
        "reasoning": "Fast, strong, suitable for large data volumes"
      },
      {
        "requirement": "Verify software updates haven't been tampered with",
        "recommended": "SHA-256 hash + RSA/ECDSA signature",
        "type": "Hashing + Digital signature",
        "reasoning": "Hash ensures integrity, signature proves authenticity"
      },
      {
        "requirement": "Secure key exchange over untrusted network",
        "recommended": "ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)",
        "type": "Asymmetric key exchange",
        "reasoning": "Perfect forward secrecy, efficient key agreement"
      },
      {
        "requirement": "Store user passwords securely",
        "recommended": "bcrypt or Argon2",
        "type": "Password hashing",
        "reasoning": "Slow by design, includes salt, resists GPU attacks"
      }
    ],
    "expected_outcome": "Match security requirements to appropriate cryptographic solutions",
    "reflection_questions": [
      "Why can't you use AES for digital signatures?",
      "What's the difference between hashing and encryption?",
      "Why are password hashes different from regular cryptographic hashes?"
    ]
  },
  "what_would_you_do": {
    "scenario": "You're designing encryption for SecureHealth's new mobile app. The app stores patient data locally for offline access. Development team wants to use MD5 for password hashing because 'it's fast' and AES-128 for data encryption because 'it's good enough.'",
    "context": "The app will store PHI. Users expect the app to work offline in areas with poor connectivity. Performance on older phones is a concern.",
    "question": "What cryptographic approach do you recommend?",
    "options": [
      {
        "id": "a",
        "text": "Accept the team's proposal - MD5 and AES-128 will work fine",
        "is_best": false,
        "feedback": "MD5 is cryptographically broken and should never be used for passwords. Fast hashing is actually bad for passwords because it enables brute force attacks.",
        "consequences": "Password database leaked. MD5 hashes cracked in hours. All patient accounts compromised."
      },
      {
        "id": "b",
        "text": "Require bcrypt/Argon2 for passwords, AES-256 for data encryption",
        "is_best": true,
        "feedback": "Correct! Password hashing must be slow (bcrypt/Argon2) to resist brute force. AES-256 provides appropriate protection for PHI. Performance impact is minimal on modern devices.",
        "consequences": "App launches securely. Even if device is stolen, data remains protected."
      },
      {
        "id": "c",
        "text": "Use SHA-256 for passwords since it's not broken like MD5",
        "is_best": false,
        "feedback": "SHA-256 is a fast hash, not designed for passwords. Fast = bad for passwords because attackers can try billions of guesses quickly. Need purpose-built password hashing.",
        "consequences": "SHA-256 password hashes cracked with GPU farm in days."
      },
      {
        "id": "d",
        "text": "Don't store any data locally - require constant connectivity",
        "is_best": false,
        "feedback": "This ignores the legitimate business requirement for offline access. Security should enable business needs, not block them.",
        "consequences": "App unusable in rural areas. Patients can't access their data when needed most."
      }
    ],
    "key_lesson": "Use cryptographic algorithms for their intended purpose: slow password hashing (bcrypt/Argon2) for passwords, strong symmetric encryption (AES-256) for data at rest."
  }
}